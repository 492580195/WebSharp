<Type Name="Instance" FullName="PepperSharp.Instance">
  <TypeSignature Language="C#" Value="public class Instance : PepperSharp.NativeInstance" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Instance extends PepperSharp.NativeInstance" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.PepperSharp</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>PepperSharp.NativeInstance</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
             An instance is a rectangle on a web page that is managed by a PepperPlugin module.
    </summary>
    <remarks>
      <para>
        An instance may have a dimension of width = 0 and height = 0, meaning that the instance does not have any visible component on the web page.
        </para>
      <para>
        An instance is created by including an <c>&lt;embed&gt;&lt;/embed&gt;</c> element in a web page.
        </para>
      <list type="bullet">
        <item>
          <term>
            <para>
        The <c>&lt;embed&gt;&lt;/embed&gt;</c> element references a Dot Net class that implements the PepperSharp API and loads the appropriate version of the PepperPlugin module.
        </para>
          </term>
        </item>
        <item>
          <term>
            <para>
        A PepperPlugin module may be included in a web page multiple times by using multiple <c>&lt;embed&gt;&lt;/embed&gt;</c> elements that refer to the class implementation; in this case the Native Client runtime system loads the module once and creates multiple instances that are managed by the module.
        </para>
          </term>
        </item>
      </list>
    </remarks>
    <example>
      <code lang="C#">
             using System;
             
             using PepperSharp;
             
             namespace HelloWorld
             {
                public class HelloWorld : Instance
                {
                    public HelloWorld(IntPtr handle) : base(handle)
                    {
                        Initialize += OnInitialize;
                    }
            
                    private void OnInitialize(object sender, InitializeEventArgs args)
                    {
                        LogToConsoleWithSource(PPLogLevel.Log, "HelloWorld.HelloWorld", "Hello from C#");
                    }
                }
             }
             </code>
    </example>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Instance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
             Default constructor not supported.
             </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Can not create a managed Instance</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Instance (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged Native Client instance</param>
        <summary>
             A constructor used when creating managed representations of unmanaged objects; called by the PepperPlugin Native Client implementation.
             </summary>
        <remarks>
             This constructor is invoked by the Native Client runtime infrastructure to create a new managed representation for a pointer to an unmanaged pp:Instance object. You should not invoke this method directly
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindGraphics">
      <MemberSignature Language="C#" Value="public bool BindGraphics (PepperSharp.PPResource graphics2d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool BindGraphics(valuetype PepperSharp.PPResource graphics2d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="graphics2d" Type="PepperSharp.PPResource" />
      </Parameters>
      <Docs>
        <param name="graphics2d">A Graphics2D to bind</param>
        <summary>
             Binds the given graphics as the current display surface.
             </summary>
        <returns>true if bind was successful or false if the device was not the correct type. On success, a reference to the device will be held by the instance, so the caller can release its reference if it chooses.</returns>
        <remarks>
          <para>             
             The contents of this device is what will be displayed in the instance's area on the web page. 
             The device must be a 2D or a 3D device.
          </para>
          <para>             
             You can pass an IsNull (default constructed) Graphics2D as the device parameter to unbind all 
             devices from the given instance. The instance will then appear transparent. Re-binding the same 
             device will return true and will do nothing.
          </para>
          <para>             
             Any previously-bound device will be released. It is an error to bind a device when it is already
             bound to another instance. If you want to move a device between instances, first unbind it from 
             the old one, and then rebind it to the new one.
          </para>
          <para>             
             Binding a device will invalidate that portion of the web page to flush the contents of the new 
             device to the screen.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearInputEventRequest">
      <MemberSignature Language="C#" Value="public void ClearInputEventRequest (PepperSharp.PPInputEventClass eventClasses);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearInputEventRequest(valuetype PepperSharp.PPInputEventClass eventClasses) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventClasses" Type="PepperSharp.PPInputEventClass" />
      </Parameters>
      <Docs>
        <param name="eventClasses">A combination of flags from PP_InputEvent_Class that identifies the classes of events the instance is no longer interested in.</param>
        <summary>
             Requests that input events corresponding to the given input classes no longer be delivered to the instance.
        </summary>
        <remarks>
          <para>            
             By default, no input events are delivered.If you have previously requested input events using 
             RequestInputEvents() or RequestFilteringInputEvents(), this function will unregister handling 
             for the given instance.This will allow greater browser performance for those events.
          </para>
          <para>
            <block subset="none" type="note">           
             You may still get some input events after clearing the flag if they were dispatched before the request was cleared. For example, if there are 3 mouse move events waiting to be delivered, and you clear the mouse event class during the processing of the first one, you'll still receive the next two. You just won't get more events generated.
             </block>
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.Instance.MouseEventArgs&gt; ContextMenu;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.Instance/MouseEventArgs&gt; ContextMenu" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.Instance+MouseEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a ContextMenu InputEvent.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;bool&gt; FocusChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;bool&gt; FocusChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when an instance has gained or lost focus.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GamepadsSample">
      <MemberSignature Language="C#" Value="public void GamepadsSample (out PepperSharp.GamepadsSampleData sampleData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GamepadsSample(valuetype PepperSharp.GamepadsSampleData sampleData) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sampleData" Type="PepperSharp.GamepadsSampleData&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="sampleData">The data for all gamepads connected to the system.</param>
        <summary>
             Allows retrieving data from gamepad/joystick devices that are connected to the system.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleDocumentLoad">
      <MemberSignature Language="C#" Value="public virtual bool HandleDocumentLoad (PepperSharp.PPResource urlLoader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HandleDocumentLoad(valuetype PepperSharp.PPResource urlLoader) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="urlLoader" Type="PepperSharp.PPResource" />
      </Parameters>
      <Docs>
        <param name="urlLoader">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleMessage">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.Var&gt; HandleMessage;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.Var&gt; HandleMessage" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.Var&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls PostMessage() on the DOM element for the instance in JavaScript.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IMECompositionEnd">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.IMEInputEvent&gt; IMECompositionEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.IMEInputEvent&gt; IMECompositionEnd" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.IMEInputEvent&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a IMEInputEvent for CompositionEnd.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IMECompositionStart">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.IMEInputEvent&gt; IMECompositionStart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.IMEInputEvent&gt; IMECompositionStart" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.IMEInputEvent&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a IMEInputEvent for CompositionStart.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IMECompositionUpdate">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.IMEInputEvent&gt; IMECompositionUpdate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.IMEInputEvent&gt; IMECompositionUpdate" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.IMEInputEvent&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a IMEInputEvent for CompositionUpdate.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IMEText">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.IMEInputEvent&gt; IMEText;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.IMEInputEvent&gt; IMEText" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.IMEInputEvent&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a IMEInputEvent for Text.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public event PepperSharp.Instance.InitializeDelegateAndHandler Initialize;" />
      <MemberSignature Language="ILAsm" Value=".event class PepperSharp.Instance/InitializeDelegateAndHandler Initialize" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>PepperSharp.Instance+InitializeDelegateAndHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Handler for Initialize 
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputEvents">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.InputEvent&gt; InputEvents;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.InputEvent&gt; InputEvents" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.InputEvent&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullFrame">
      <MemberSignature Language="C#" Value="public bool IsFullFrame { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullFrame" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Getter that returns if the instance is full-frame (repr).
             </summary>
        <value>A <see cref="T:System.Boolean">bool</see> that specifies whether the is full-frame (repr).</value>
        <remarks>
             Such an instance represents the entire document in a frame rather than an embedded resource.
             This can happen if the user does a top-level navigation or the page specifies an iframe to a 
             resource with a MIME type registered by the module.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullScreen">
      <MemberSignature Language="C#" Value="public bool IsFullScreen { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullScreen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Getter and Setter that checks whether the module instance is currently in
             fullscreen mode or sets the instance to full screen mode.
             </summary>
        <value>A <see cref="T:System.Boolean" />  that specifies whether the module instance is currently in
             fullscreen mode or sets the instance to full screen mode.</value>
        <remarks>
          <para>                     
             The setter switches the module instance to and from fullscreen
             mode.
          </para>
          <para>                     
             The transition to and from fullscreen mode is asynchronous. During the
             transition, IsFullscreen() will return the previous value and
             no 2D or 3D device can be bound. The transition ends at DidChangeView()
             when IsFullscreen() returns the new value. You might receive other
             DidChangeView() calls while in transition.
          </para>
          <para>                     
             The transition to fullscreen mode can only occur while the browser is
             processing a user gesture, even if <see langword="true" /> is returned.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Throws InvalidOperationException if there was an error transitioning to or from
             fullscreen mode.</exception>
      </Docs>
    </Member>
    <Member MemberName="KeyChar">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.Instance.KeyboardEventArgs&gt; KeyChar;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.Instance/KeyboardEventArgs&gt; KeyChar" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.Instance+KeyboardEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a KeyboardInputEvent for Char.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.Instance.KeyboardEventArgs&gt; KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.Instance/KeyboardEventArgs&gt; KeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.Instance+KeyboardEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a KeyboardInputEvent for KeyDown.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.Instance.KeyboardEventArgs&gt; KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.Instance/KeyboardEventArgs&gt; KeyUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.Instance+KeyboardEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a KeyboardInputEvent for KeyUp.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogToConsole">
      <MemberSignature Language="C#" Value="public void LogToConsole (PepperSharp.PPLogLevel level, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LogToConsole(valuetype PepperSharp.PPLogLevel level, object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="PepperSharp.PPLogLevel" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="level">The log level</param>
        <param name="value">The managed object to log.</param>
        <summary>
             Logs the given message to the JavaScript console associated with the given plugin instance with the given logging level.
             </summary>
        <remarks>             The name of the plugin issuing the log message will be automatically prepended to the message.The value may be any type of <see cref="T:PepperSharp.Var" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogToConsoleWithSource">
      <MemberSignature Language="C#" Value="public void LogToConsoleWithSource (PepperSharp.PPLogLevel level, string source, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LogToConsoleWithSource(valuetype PepperSharp.PPLogLevel level, string source, object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="PepperSharp.PPLogLevel" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="level">The log level</param>
        <param name="source">Must be a string value</param>
        <param name="value">The managed object to log.</param>
        <summary>
             Logs a message to the console with the given source information rather than using the internal PPAPI plugin name.
             
             </summary>
        <remarks>
             The regular log function will automatically prepend the name of your plugin to the message as the "source" of the message.  
             Some plugins may wish to override this. 
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.Instance.MouseEventArgs&gt; MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.Instance/MouseEventArgs&gt; MouseDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.Instance+MouseEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a MouseDown InputEvent.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.Instance.MouseEventArgs&gt; MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.Instance/MouseEventArgs&gt; MouseEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.Instance+MouseEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a MouseEnter InputEvent.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.Instance.MouseEventArgs&gt; MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.Instance/MouseEventArgs&gt; MouseLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.Instance+MouseEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a MouseLeave InputEvent.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.Instance.MouseEventArgs&gt; MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.Instance/MouseEventArgs&gt; MouseMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.Instance+MouseEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a MouseMove InputEvent.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.Instance.MouseEventArgs&gt; MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.Instance/MouseEventArgs&gt; MouseUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.Instance+MouseEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a MouseUp InputEvent.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenu">
      <MemberSignature Language="C#" Value="protected virtual bool OnContextMenu (PepperSharp.Instance.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnContextMenu(class PepperSharp.Instance/MouseEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.Instance+MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that a context menu should be shown.
             </summary>
        <returns>true if handled, false otherwise.</returns>
        <remarks>
          <para>              
             This message will be sent when the user right-clicks or performs another OS-specific mouse command that should open a context menu.When this event is delivered depends on the system, on some systems (Mac) it will delivered after the mouse down event, and on others (Windows) it will be delivered after the mouse up event.
          </para>
          <para>             
             You will always get the normal mouse events. For example, you may see OnMouseDown, OnContextMenu, OnMouseUp or OnMouseDown, OnMouseUp, OnContextMenu.
           </para>
          <para>             
             The return value from the event handler determines if the context menu event will be passed to the page when you are using filtered input events(via RequestFilteringInputEvents()). In non-filtering mode the event will never be propagated and no context menu will be displayed.If you are handling mouse events in filtering mode, you may want to return true from this event even if you do not support a context menu to suppress the default one.
          </para>
          <para>              
             Register for this event using the PPInputEventClass.Mouse class.
          </para>
          <para> 
             The OnContextMenu method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
          </para>
        </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                MouseDown += HandleMouseEvents;
                MouseEnter += HandleMouseEvents;
                MouseLeave += HandleMouseEvents;
                MouseMove += HandleMouseEvents;
                MouseUp += HandleMouseEvents;
                ContextMenu += HandleMouseEvents;
                RequestInputEvents(PPInputEventClass.Mouse);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnFocusChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnFocusChanged (bool hasFocus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFocusChanged(bool hasFocus) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hasFocus" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="hasFocus">Indicates the new focused state of the instance.</param>
        <summary>
             Raises the FocusChanged event when an instance has gained or lost focus.
             </summary>
        <remarks>
          <para>
             Having focus means that keyboard events will be sent to the instance.  An instance's default 
             condition is that it will not have focus.
          </para>
          <para>
             The focus flag takes into account both browser tab and window focus as well as focus of the plugin 
             element on the page. In order to be deemed to have focus, the browser window must be topmost, 
             the tab must be selected in the window, and the instance must be the focused element on the page.
          </para>
          <para>
             The OnFocusChanged method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
          </para>
          <para>
            <block subset="none" type="note">
             Clicks on instances will give focus only if you handle the click event. 
             Return true from HandleInputEvent in InputEvent (or use unfiltered events) to signal that the 
             click event was handled. Otherwise, the browser will bubble the event and give focus to the element 
             on the page that actually did end up consuming it.  If you're not getting focus, check to make sure
             you're either requesting them via RequestInputEvents() (which implicitly marks all input events as 
             consumed) or via RequestFilteringInputEvents() and returning true from your event handler.
             </block>
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleMessage">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleMessage (PepperSharp.Var message);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleMessage(class PepperSharp.Var message) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="PepperSharp.Var" />
      </Parameters>
      <Docs>
        <param name="message">A <see cref="T:PepperSharp.Var"></see> which has been converted from a JavaScript value. JavaScript 
             array/object types are supported from Chrome M29 onward. All JavaScript values are copied 
             when passing them to the plugin.
             </param>
        <summary>
             Raises the HandleMessage event when the browser calls PostMessage() on the DOM element for 
             the instance in JavaScript.
             </summary>
        <remarks>
             The OnHandleMessage method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
          <para>
             PostMessage() in the JavaScript interface is asynchronous, meaning JavaScript execution 
             will not be blocked while OnRecieveMessage is processing the message.
          </para>
          <para>     
             <block subset="none" type="note">
             When converting JavaScript arrays, any object properties whose name is not an array index are 
             ignored.  When passing arrays and objects, the entire reference graph will be converted and 
             transferred.  If the reference graph has cycles, the message will not be sent and an error will 
             be logged to the console.
             </block>
             </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIMECompositionEnd">
      <MemberSignature Language="C#" Value="protected virtual bool OnIMECompositionEnd (PepperSharp.IMEInputEvent e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnIMECompositionEnd(class PepperSharp.IMEInputEvent e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.IMEInputEvent" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that an input method composition process has completed.
             
             Register for this event using the PPInputEventClass.IME class.
             </summary>
        <returns />
        <remarks>
             The OnIMECompositionEnd method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example><code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                IMECompositionEnd += HandleIMEEvents;
                IMECompositionStart += HandleIMEEvents;
                IMECompositionUpdate += HandleIMEEvents;
                IMEText += HandleIMEEvents;
                
                RequestFilteringInputEvents(PPInputEventClass.IME);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnIMECompositionStart">
      <MemberSignature Language="C#" Value="protected virtual bool OnIMECompositionStart (PepperSharp.IMEInputEvent e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnIMECompositionStart(class PepperSharp.IMEInputEvent e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.IMEInputEvent" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that an input method composition process has just started.
             
             Register for this event using the PPInputEventClass.IME class.
             </summary>
        <returns />
        <remarks>
             The OnIMECompositionStart method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example><code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                IMECompositionEnd += HandleIMEEvents;
                IMECompositionStart += HandleIMEEvents;
                IMECompositionUpdate += HandleIMEEvents;
                IMEText += HandleIMEEvents;
                
                RequestFilteringInputEvents(PPInputEventClass.IME);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnIMECompositionUpdate">
      <MemberSignature Language="C#" Value="protected virtual bool OnIMECompositionUpdate (PepperSharp.IMEInputEvent e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnIMECompositionUpdate(class PepperSharp.IMEInputEvent e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.IMEInputEvent" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that the input method composition string is updated.
             
             Register for this event using the PPInputEventClass.IME class.
             </summary>
        <returns />
        <remarks>
             The OnIMECompositionUpdate method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                IMECompositionEnd += HandleIMEEvents;
                IMECompositionStart += HandleIMEEvents;
                IMECompositionUpdate += HandleIMEEvents;
                IMEText += HandleIMEEvents;
                
                RequestFilteringInputEvents(PPInputEventClass.IME);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnIMEText">
      <MemberSignature Language="C#" Value="protected virtual bool OnIMEText (PepperSharp.IMEInputEvent e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnIMEText(class PepperSharp.IMEInputEvent e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.IMEInputEvent" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that an input method committed a string.
             
             Register for this event using the PPInputEventClass.IME class.
             </summary>
        <returns />
        <remarks>
             The OnIMEText method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                IMECompositionEnd += HandleIMEEvents;
                IMECompositionStart += HandleIMEEvents;
                IMECompositionUpdate += HandleIMEEvents;
                IMEText += HandleIMEEvents;
                
                RequestFilteringInputEvents(PPInputEventClass.IME);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnInitialize">
      <MemberSignature Language="C#" Value="protected virtual bool OnInitialize (PepperSharp.Instance.InitializeEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnInitialize(class PepperSharp.Instance/InitializeEventArgs args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="PepperSharp.Instance+InitializeEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">An instance of InitializeEventArgs that is cancelable</param>
        <summary>
             Raise event to intialize the instance with the provided arguments. This
             event will be raised immediately after the instance object is constructed.
             </summary>
        <returns>true if the event was not canceled and falce if the event was canceled for some reason.</returns>
        <remarks>
             The OnInitialize method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInputEvents">
      <MemberSignature Language="C#" Value="protected virtual bool OnInputEvents (PepperSharp.InputEvent inputEvent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnInputEvents(class PepperSharp.InputEvent inputEvent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputEvent" Type="PepperSharp.InputEvent" />
      </Parameters>
      <Docs>
        <param name="inputEvent">The event to handle.</param>
        <summary>
             Raises the HandleInput event from the browser.
            
             The default implementation does nothing and returns false.
             
             In order to receive input events, you must register for them by calling RequestInputEvents() or 
             RequestFilteringInputEvents(). By default, no events are delivered.
             
             If the event was handled, it will not be forwarded to any default handlers.If it was not handled, 
             it may be dispatched to a default handler.So it is important that an instance respond accurately 
             with whether event propagation should continue.
             
             Event propagation also controls focus.If you handle an event like a mouse event, typically the 
             instance will be given focus. Returning false from a filtered event handler or not registering for 
             an event type means that the click will be given to a lower part of the page and your instance 
             will not receive focus.This allows an instance to be partially transparent, where clicks on the 
             transparent areas will behave like clicks to the underlying page.
             
             In general, you should try to keep input event handling short. Especially for filtered input events,
             the browser or page may be blocked waiting for you to respond.
             
             The caller of this function will maintain a reference to the input event resource during this call.
             Unless you take a reference to the resource to hold it for later, you don't need to release it.
             </summary>
        <returns>true if the event was handled, false if not. If you have registered to filter this class of events by calling RequestFilteringInputEvents, and you return false, the event will be forwarded to the page (and eventually the browser) for the default handling. For non-filtered events, the return value will be ignored.</returns>
        <remarks>
             The OnInputEvents method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <notes>
             If you're not receiving input events, make sure you register for the event classes you want 
             by calling RequestInputEvents or RequestFilteringInputEvents. If you're still not receiving 
             keyboard input events, make sure you're returning true (or using a non-filtered event handler) for
             mouse events. Otherwise, the instance will not receive focus and keyboard events will not be sent.
             
             Refer to RequestInputEvents and RequestFilteringInputEvents for further information.
             </notes>
      </Docs>
    </Member>
    <Member MemberName="OnKeyChar">
      <MemberSignature Language="C#" Value="protected virtual bool OnKeyChar (PepperSharp.Instance.KeyboardEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnKeyChar(class PepperSharp.Instance/KeyboardEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.Instance+KeyboardEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that a character was typed.
             
             Use this for text input. Key down events may generate 0, 1, or more than one character event depending on the key, locale, and operating system.
            
             Register for this event using the PPInputEventClass.Keyboard class.
             </summary>
        <returns />
        <remarks>
             The OnKeyChar method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                KeyUp += HandleKeyboardEvents;
                KeyDown += HandleKeyboardEvents;
                KeyChar += HandleKeyboardEvents;
                RawKeyDown += HandleKeyboardEvents;
                
                RequestFilteringInputEvents(PPInputEventClass.Keyboard);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual bool OnKeyDown (PepperSharp.Instance.KeyboardEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnKeyDown(class PepperSharp.Instance/KeyboardEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.Instance+KeyboardEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that a key was pressed.
             
             This does not necessarily correspond to a character depending on the key and language.  Use the OnKeyChar for character input.
            
             Register for this event using the PPInputEventClass.Keyboard class.
             </summary>
        <returns />
        <remarks>
             The OnKeyDown method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                KeyUp += HandleKeyboardEvents;
                KeyDown += HandleKeyboardEvents;
                KeyChar += HandleKeyboardEvents;
                RawKeyDown += HandleKeyboardEvents;
                
                RequestFilteringInputEvents(PPInputEventClass.Keyboard);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual bool OnKeyUp (PepperSharp.Instance.KeyboardEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnKeyUp(class PepperSharp.Instance/KeyboardEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.Instance+KeyboardEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that a key was released.
             
             Register for this event using the PPInputEventClass.Keyboard class.
             </summary>
        <returns />
        <remarks>
             The OnKeyUp method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                KeyUp += HandleKeyboardEvents;
                KeyDown += HandleKeyboardEvents;
                KeyChar += HandleKeyboardEvents;
                RawKeyDown += HandleKeyboardEvents;
                RequestFilteringInputEvents(PPInputEventClass.Keyboard);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual bool OnMouseDown (PepperSharp.Instance.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnMouseDown(class PepperSharp.Instance/MouseEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.Instance+MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that a mouse button was pressed.
             
             Register for this event using the PPInputEventClass.Mouse class.
             </summary>
        <returns>true if handled, false otherwise.</returns>
        <remarks>
             The OnMouseDown method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                MouseDown += HandleMouseEvents;
                MouseEnter += HandleMouseEvents;
                MouseLeave += HandleMouseEvents;
                MouseMove += HandleMouseEvents;
                MouseUp += HandleMouseEvents;
                ContextMenu += HandleMouseEvents;
                RequestInputEvents(PPInputEventClass.Mouse);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual bool OnMouseEnter (PepperSharp.Instance.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnMouseEnter(class PepperSharp.Instance/MouseEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.Instance+MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that the mouse entered the instance's bounds.
             
             Register for this event using the PPInputEventClass.Mouse class.
             </summary>
        <returns>true if handled, false otherwise.</returns>
        <remarks>
             The OnMouseEnter method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                MouseDown += HandleMouseEvents;
                MouseEnter += HandleMouseEvents;
                MouseLeave += HandleMouseEvents;
                MouseMove += HandleMouseEvents;
                MouseUp += HandleMouseEvents;
                ContextMenu += HandleMouseEvents;
                RequestInputEvents(PPInputEventClass.Mouse);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual bool OnMouseLeave (PepperSharp.Instance.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnMouseLeave(class PepperSharp.Instance/MouseEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.Instance+MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that a mouse left the instance's bounds.
             
             Register for this event using the PPInputEventClass.Mouse class.
             </summary>
        <returns>true if handled, false otherwise.</returns>
        <remarks>
             The OnMouseLeave method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                MouseDown += HandleMouseEvents;
                MouseEnter += HandleMouseEvents;
                MouseLeave += HandleMouseEvents;
                MouseMove += HandleMouseEvents;
                MouseUp += HandleMouseEvents;
                ContextMenu += HandleMouseEvents;
                RequestInputEvents(PPInputEventClass.Mouse);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual bool OnMouseMove (PepperSharp.Instance.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnMouseMove(class PepperSharp.Instance/MouseEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.Instance+MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that a mouse button was moved when it is over the instance or dragged out of it.
             
             Register for this event using the PPInputEventClass.Mouse class.
             </summary>
        <returns>true if handled, false otherwise.</returns>
        <remarks>
             The OnMouseMove method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                MouseDown += HandleMouseEvents;
                MouseEnter += HandleMouseEvents;
                MouseLeave += HandleMouseEvents;
                MouseMove += HandleMouseEvents;
                MouseUp += HandleMouseEvents;
                ContextMenu += HandleMouseEvents;
                RequestInputEvents(PPInputEventClass.Mouse);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual bool OnMouseUp (PepperSharp.Instance.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnMouseUp(class PepperSharp.Instance/MouseEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.Instance+MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that a mouse button was released.
             
             Register for this event using the PPInputEventClass.Mouse class.
             </summary>
        <returns>true if handled, false otherwise.</returns>
        <remarks>
             The OnMouseUp method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                MouseDown += HandleMouseEvents;
                MouseEnter += HandleMouseEvents;
                MouseLeave += HandleMouseEvents;
                MouseMove += HandleMouseEvents;
                MouseUp += HandleMouseEvents;
                ContextMenu += HandleMouseEvents;
                RequestInputEvents(PPInputEventClass.Mouse);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnRawKeyDown">
      <MemberSignature Language="C#" Value="protected virtual bool OnRawKeyDown (PepperSharp.Instance.KeyboardEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnRawKeyDown(class PepperSharp.Instance/KeyboardEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.Instance+KeyboardEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that a key transitioned from "up" to "down".
             
             Register for this event using the PPInputEventClass.Keyboard class.
             </summary>
        <returns />
        <remarks>
             The OnRawKeyDown method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                KeyUp += HandleKeyboardEvents;
                KeyDown += HandleKeyboardEvents;
                KeyChar += HandleKeyboardEvents;
                RawKeyDown += HandleKeyboardEvents;
                
                RequestFilteringInputEvents(PPInputEventClass.Keyboard);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnTouchCancel">
      <MemberSignature Language="C#" Value="protected virtual bool OnTouchCancel (PepperSharp.TouchInputEvent e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnTouchCancel(class PepperSharp.TouchInputEvent e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.TouchInputEvent" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that a touch event was canceled.
             
             Register for this event using the PPInputEventClass.Touch class.
             </summary>
        <returns />
        <remarks>
             The OnTouchCancel method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                TouchStart += HandleTouchEvents;
                TouchEnd += HandleTouchEvents;
                TouchMove += HandleTouchEvents;
                TouchCancel += HandleTouchEvents;
                
                RequestFilteringInputEvents(PPInputEventClass.Touch);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnd">
      <MemberSignature Language="C#" Value="protected virtual bool OnTouchEnd (PepperSharp.TouchInputEvent e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnTouchEnd(class PepperSharp.TouchInputEvent e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.TouchInputEvent" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that a finger was released on a touch-enabled device.
             
             Register for this event using the PPInputEventClass.Touch class.
             </summary>
        <returns />
        <remarks>
             The OnTouchEnd method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                TouchStart += HandleTouchEvents;
                TouchEnd += HandleTouchEvents;
                TouchMove += HandleTouchEvents;
                TouchCancel += HandleTouchEvents;
                
                RequestFilteringInputEvents(PPInputEventClass.Touch);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected virtual bool OnTouchMove (PepperSharp.TouchInputEvent e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnTouchMove(class PepperSharp.TouchInputEvent e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.TouchInputEvent" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that a finger was moved on a touch-enabled device.
             
             Register for this event using the PPInputEventClass.Touch class.
             </summary>
        <returns />
        <remarks>
             The OnTouchMove method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                TouchStart += HandleTouchEvents;
                TouchEnd += HandleTouchEvents;
                TouchMove += HandleTouchEvents;
                TouchCancel += HandleTouchEvents;
                
                RequestFilteringInputEvents(PPInputEventClass.Touch);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnTouchStart">
      <MemberSignature Language="C#" Value="protected virtual bool OnTouchStart (PepperSharp.TouchInputEvent e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnTouchStart(class PepperSharp.TouchInputEvent e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.TouchInputEvent" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that a finger was placed on a touch-enabled device.
             
             Register for this event using the PPInputEventClass.Touch class.
             </summary>
        <returns />
        <remarks>
             The OnTouchStart method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
            
                TouchStart += HandleTouchEvents;
                TouchEnd += HandleTouchEvents;
                TouchMove += HandleTouchEvents;
                TouchCancel += HandleTouchEvents;
                
                RequestFilteringInputEvents(PPInputEventClass.Touch);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="OnViewChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnViewChanged (PepperSharp.View view);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnViewChanged(class PepperSharp.View view) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="PepperSharp.View" />
      </Parameters>
      <Docs>
        <param name="view">The view object that contains the new view properties</param>
        <summary>
             Raises the ViewChange event when the view information for the Instance
             has changed. See the <c>View</c> object for information.
            
             Most implementations will want to check if the size and user visibility
             changed, and either resize themselves or start/stop generating updates.
             </summary>
        <remarks>
             The OnViewChanged method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWheel">
      <MemberSignature Language="C#" Value="protected virtual bool OnWheel (PepperSharp.Instance.WheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnWheel(class PepperSharp.Instance/WheelEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="PepperSharp.Instance+WheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event args</param>
        <summary>
             Notification that the scroll wheel was used.
            
             Register for this event using the PPInputEventClass.Wheel class.
             </summary>
        <returns>true if handled, false otherwise.</returns>
        <remarks>
             The OnWheel method also enables derived classes to handle the event without attaching 
             a delegate. This is the preferred technique for handling the event in a derived class.
             </remarks>
        <example>
          <code lang="C#">
             public InputEventInstance(IntPtr handle) : base(handle)
             {
                Wheel += HandleWheel;
                RequestInputEvents(PPInputEventClass.Wheel);
             }
             </code>
        </example>
      </Docs>
    </Member>
    <!--Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static PepperSharp.PPInstance op_Implicit (PepperSharp.Instance instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype PepperSharp.PPInstance op_Implicit(class PepperSharp.Instance instance) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>PepperSharp.PPInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="PepperSharp.Instance" />
      </Parameters>
      <Docs>
        <param name="instance">
        </param>
        <summary>
             Implicit conversion to unmanaged pointer (Handle).  Used by PInvoke.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member-->
    <Member MemberName="PostMessage">
      <MemberSignature Language="C#" Value="public void PostMessage (object message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PostMessage(object message) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">A manage object that will be converted to a JavaScript value.  JavaScript 
             array/object types are supported from Chrome M29 onward. All JavaScript values are copied 
             when passing them to the plugin.
             </param>
        <summary>
             Asynchronously invokes any listeners for message events on the DOM element for the given instance.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PPInstance">
      <MemberSignature Language="C#" Value="public PepperSharp.PPInstance PPInstance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype PepperSharp.PPInstance PPInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>PepperSharp.PPInstance</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Getter that returnes the unmanaged pointer (Handle) of this instance.
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RawKeyDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.Instance.KeyboardEventArgs&gt; RawKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.Instance/KeyboardEventArgs&gt; RawKeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.Instance+KeyboardEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a KeyboardInputEvent for RawKeydown.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestFilteringInputEvents">
      <MemberSignature Language="C#" Value="public PepperSharp.PPError RequestFilteringInputEvents (PepperSharp.PPInputEventClass eventClasses);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype PepperSharp.PPError RequestFilteringInputEvents(valuetype PepperSharp.PPInputEventClass eventClasses) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>PepperSharp.PPError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventClasses" Type="PepperSharp.PPInputEventClass" />
      </Parameters>
      <Docs>
        <param name="eventClasses">A combination of flags from PP_InputEvent_Class that identifies the classes of events the instance is requesting. The flags are combined by logically ORing their values.</param>
        <summary>
             Requests that input events corresponding to the given input events 
             are delivered to the instance for filtering.
             </summary>
        <returns>OK if the operation succeeded, BADARGUMENT if instance is invalid, or NOTSUPPORTED if 
             one of the event class bits were illegal. In the case of an invalid bit, all valid bits will be 
             applied and only the illegal bits will be ignored.
             </returns>
        <remarks>
          <para>             
             By default, no input events are delivered.In most cases you would register to receive events by 
             calling RequestInputEvents(). In some cases, however, you may wish to filter events such that 
             they can be bubbled up to the DOM.In this case, register for those classes of events using this 
             function instead of RequestInputEvents(). Keyboard events must always be registered in filtering 
             mode.
          </para>
          <para>             
             Filtering input events requires significantly more overhead than just delivering them to the 
             instance. As such, you should only request filtering in those cases where it's absolutely
             necessary. The reason is that it requires the browser to stop and block for the instance to 
             handle the input event, rather than sending the input event asynchronously. This can have 
             significant overhead.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestInputEvents">
      <MemberSignature Language="C#" Value="public PepperSharp.PPError RequestInputEvents (PepperSharp.PPInputEventClass eventClasses);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype PepperSharp.PPError RequestInputEvents(valuetype PepperSharp.PPInputEventClass eventClasses) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>PepperSharp.PPError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventClasses" Type="PepperSharp.PPInputEventClass" />
      </Parameters>
      <Docs>
        <param name="eventClasses">A combination of flags from PP_InputEvent_Class that identifies the classes of events the instance is requesting. The flags are combined by logically ORing their values.</param>
        <summary>
             Requests that input events corresponding to the given input events are delivered to the instance.
             </summary>
        <returns>PP_OK if the operation succeeded, PP_ERROR_BADARGUMENT if instance is invalid, or PP_ERROR_NOTSUPPORTED if one of the event class bits were illegal. In the case of an invalid bit, all valid bits will be applied and only the illegal bits will be ignored.</returns>
        <remarks>
          <para>             
             By default, no input events are delivered.Call this function with the classes of events you are
             interested in to have them be delivered to the instance. Calling this function will override any 
             previous setting for each specified class of input events(for example, if you previously called 
             RequestFilteringInputEvents(), this function will set those events to non-filtering mode).
          </para>
          <para>             
             Input events may have high overhead, so you should only request input events that your plugin will 
             actually handle.For example, the browser may do optimizations for scroll or touch events that can
             be processed substantially faster if it knows there are no non-default receivers for that message. 
             Requesting that such messages be delivered, even if they are processed very quickly, may have a 
             noticeable effect on the performance of the page.
          </para>
          <para>             
             When requesting input events through this function, the events will be delivered and not bubbled 
             to the page.This means that even if you aren't interested in the message, no other parts of the 
             page will get the message.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScreenSize">
      <MemberSignature Language="C#" Value="public PepperSharp.PPSize ScreenSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype PepperSharp.PPSize ScreenSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>PepperSharp.PPSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Gets the size of the screen in pixels. The module instance
             will be resized to this size when IsFullscreen is set to true to enter
             fullscreen mode.
             </summary>
        <value>A <see cref="T:PepperSharp.PPSize">PPSize</see> that represents the width and height of the screen.</value>
        <exception cref="T:System.InvalidOperationException">Throws InvalidOperationException if there was an error obtaining the screen size for
             some reason.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCursor">
      <MemberSignature Language="C#" Value="public bool SetCursor (PepperSharp.PPMouseCursorType type, PepperSharp.ImageData imageData = null, Nullable&lt;PepperSharp.PPPoint&gt; hotSpot = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SetCursor(valuetype PepperSharp.PPMouseCursorType type, class PepperSharp.ImageData imageData, valuetype System.Nullable`1&lt;valuetype PepperSharp.PPPoint&gt; hotSpot) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="PepperSharp.PPMouseCursorType" />
        <Parameter Name="imageData" Type="PepperSharp.ImageData" />
        <Parameter Name="hotSpot" Type="System.Nullable&lt;PepperSharp.PPPoint&gt;" />
      </Parameters>
      <Docs>
        <param name="type">A <c>PPMouseCursorType</c> identifying the type
             of mouse cursor to show.
             </param>
        <param name="imageData">A <c>ImageData</c> object identifying the
             custom image to set when the type is
             <c>PPMouseCursorType.CUSTOM</c>. The image must be less than 32
             pixels in each direction and must be of the system's native image format.
             When you are specifying a predefined cursor, this parameter should be a
             default-constructed ImageData.
             </param>
        <param name="hotSpot">When setting a custom cursor, this identifies the
             pixel position within the given image of the "hot spot" of the cursor.
             When specifying a stock cursor, this parameter is ignored.
             </param>
        <summary>
             Sets the given mouse cursor. The mouse cursor will be in effect whenever
             the mouse is over the given instance until it is set again by another
             call.
             </summary>
        <returns>true on success, or false if the instance or cursor type
             was invalid or if the image was too large.</returns>
        <remarks>
          <block subset="none" type="note">
            <para>
             You can hide the mouse cursor by setting it to the
             <c>PPMouseCursorType</c> type.
          </para>
            <para>
             This function allows setting both system defined mouse cursors and
             custom cursors. To set a system-defined cursor, pass the type you want
             and set the custom image to a default-constructor ImageData object.
             To set a custom cursor, set the type to
             <c>PPMouseCursorType.CUSTOM</c> and specify your image and hot
             spot.
          </para>
          </block>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchCancel">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.TouchInputEvent&gt; TouchCancel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.TouchInputEvent&gt; TouchCancel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.TouchInputEvent&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a TouchInputEvent for TouchCancel.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnd">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.TouchInputEvent&gt; TouchEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.TouchInputEvent&gt; TouchEnd" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.TouchInputEvent&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a TouchInputEvent for TouchEnd.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.TouchInputEvent&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.TouchInputEvent&gt; TouchMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.TouchInputEvent&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a TouchInputEvent for TouchMove.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchStart">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.TouchInputEvent&gt; TouchStart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.TouchInputEvent&gt; TouchStart" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.TouchInputEvent&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a TouchInputEvent for TouchStart.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.View&gt; ViewChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.View&gt; ViewChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.View&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the view information for the Instance has changed.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Wheel">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;PepperSharp.Instance.WheelEventArgs&gt; Wheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class PepperSharp.Instance/WheelEventArgs&gt; Wheel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;PepperSharp.Instance+WheelEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Event raised when the browser calls HandleInputEvent on the DOM element for the instance in JavaScript 
             that represents a Wheel InputEvent.
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
