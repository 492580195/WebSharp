# GNU Makefile based on shared rules provided by the Native Client SDK.
# See README.Makefiles for more details.

# First figure out the platform if not specified, so we can use it in the
# rest of this file.  Currently defined values: Darwin
ifeq "$(PLATFORM)" ""
PLATFORM := $(shell uname)
endif

ifeq "$(PLATFORM)" "Darwin"
    VALID_TOOLCHAINS := mac
    ifndef MONO_ROOT
        # check if pkg-config is available
        PKGCONFIG := $(shell pkg-config --libs mono-2 2> /dev/null)
        ifndef PKGCONFIG
            MONO_ROOT ?=/Library/Frameworks/Mono.framework
        endif
    endif
else
VALID_TOOLCHAINS := win
# Fill this out when and if we do a makefile for Windows
endif


NACL_SDK_ROOT ?= $(abspath $(CURDIR)/../../../nacl_sdk/pepper_canary)

TARGET = libPepperPlugin

# Define the output directory of the Tools electron-dotnet node module
# so the plugin can be found, loaded and registered correctly in electron
OUTBASE=../../Tools/electron-dotnet/bin

include $(NACL_SDK_ROOT)/tools/common.mk

OUTDIR = $(OUTBASE)/$(TOOLCHAIN)

ifdef PKGCONFIG
   CFLAGS := `pkg-config --cflags mono-2`
   LDFLAGS := `pkg-config --libs mono-2`
   $(info VAR="$(LDFLAGS)")
   LIBS = ppapi_cpp ppapi
else
   LDFLAGS :=-L$(MONO_ROOT)/Libraries
   LIBS = ppapi_cpp ppapi pthread mono-2.0.1
endif

CFLAGS += -std=c++14 -Wno-unused-variable -Wno-null-conversion -Wno-unknown-pragmas -Wno-unused-function -Wno-writable-strings -v -I$(MONO_ROOT)/Headers/mono-2.0
SOURCES = ./PepperPlugin/PepperPlugin.cpp ./PepperPlugin/pepper_entrypoints.cpp

# Build rules generated by macros from common.mk:

$(foreach src,$(SOURCES),$(eval $(call COMPILE_RULE,$(src),$(CFLAGS))))

# The PNaCl workflow uses both an unstripped and finalized/stripped binary.
# On NaCl, only produce a stripped binary for Release configs (not Debug).
ifneq (,$(or $(findstring pnacl,$(TOOLCHAIN)),$(findstring Release,$(CONFIG))))
$(eval $(call LINK_RULE,$(TARGET)_unstripped,$(SOURCES),$(LIBS),$(DEPS)))
$(eval $(call STRIP_RULE,$(TARGET),$(TARGET)_unstripped))
else
$(eval $(call LINK_RULE,$(TARGET),$(SOURCES),$(LIBS),$(DEPS)))
endif

$(eval $(call NMF_RULE,$(TARGET),))
